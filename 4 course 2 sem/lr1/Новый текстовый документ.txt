% Задание функции моделирования входного сигнала
% -- Сигнал - сумма 4-х гармоник с постоянной составляющей
% ---- Величина постоянной составляющей и амплитуды гармоник
A0 = -0.1; %(задать свое значение!)
A1 = 1;
A2 = 1;
A3 = 1;
A4 = 1;
% ---- Частоты гармоник
f1 = 300; %(задать свое значение!)
f2 = 600; %(задать свое значение!)
f3 = 1600;% (задать свое значение!)
f4 = 2100; %(задать свое значение!)
% ---- Функция расчета сигнала
s_ = @(t) A0 + A1*cos(2*pi*f1*t) + A2*cos(2*pi*f2*t);
s  = @(t) s_(t) + A3*cos(2*pi*f3*t) + A4*cos(2*pi*f4*t);
%-----------------------------------------------------------------
% Исходный сигнал моделируется выборкой с малым шагом дискретизации
% - является квазинепрерывным
T0 = 1e-6; % шаг между значениям исходного, квазинепрерывного сигнала
Dt = 1e-2; % длительность выборки (задать свое значение!)
t = 0:T0:2*Dt-T0; % множество моментов времени, соответствующих отсчетам
% --- изначально сигнал создается удвоенной длительности,
% чтоюы затем, после фильтрации, отрезать начальный участок
% для устранения переходного процесс
s00_ = s(t); % отсчеты сигнал
%s20_ = s_(t); % отсчеты информационной части сигнала

% Моделирование входного ФНЧ
% -- определяем коэффициенты фильтра Баттерворта
fm = 1000; % Ширина полосы пропускания фильтра
nf = 6; % Порядов фильтра
[b,a] = butter(nf, 2*fm*T0);
% -- производим фильтрацию сигнала
s0_ = filter(b,a,s00_);
% s0_ = s00_;
% -- отрезаем начальные участки сигналов с переходным процессом
s00 = s00_(length(s00_)/2+1:length(s00_));
s20 = s20_(length(s20_)/2+1:length(s20_));
s0 = s0_(length(s0_)/2+1:length(s0_));
t = 0:T0:Dt-T0;

% Моделирование дискретизации
fs = 5000; % Частота дискретизации (задать свое значение!)
Dn = round(1/fs/T0); % Шаг прореживания исходной выборки
T = Dn*T0; % Период дискретизации
t1 = 0:T:Dt; % Множество моментов времени дискретизированного сигнала
n = 1:Dn:length(s0); % Индексы отсчетов дискретизированного сигнала
tt = abs(t1(length(t1)) - Dt);
if tt > 0 && tt < T/2
t1 = 0:T:Dt-T;
n = 1:Dn:length(s0)- Dn;
end
s1 = s20(n); % Моделирование дискретизации - выбираем остчеты с шагом Dn

% Производим экстраполяцию дискретизированного сигнала
% -- с помощью конечного числа членов ряда Котельникова
%s2 = f_Kotelnikov_sum(t, T, s1);
% -- с помощью фиксатора нулевого порядка
s2 = f_fix0_extrapolation(t, T, s1);
% -- с помощью фиксатора первого порядка
% s2 = f_fix1_extrapolation(t, T, s1);
[b,a] = butter(6, 2*fm*T0);
s3 = filter(b,a,s2);

% Ошибка преобразования сходного сигнала
ds = s2 - s00;

% Рассчитываем амплитудный спектр исходного сигнала
F0 = abs(fft(s0)/length(s0));
% Рассчитываем амплитудный спектр дискретизированного сигнала
FF1 = abs(fft(s1)/length(s1));
df = 1/Dt; % Шаг между спектральными отсчетами
f = 0:df:10000; % Множество частот для отображения спектра (задать свое значение!)
F1 = zeros(1,length(f));
for i=1:length(f)
    j = mod(i,length(s1));
    if j == 0
        j = length(s1);
    end
    F1(i) = FF1(j);
end
% Вычисляем спектр экстраполированного сигнала и строим его
F2 = abs(fft(s2)/length(s2));

% График исходного сигнала
figure
subplot(3,1,1);
plot(t, s20);
grid on
hold on
%plot(t, s20);
plot(t, s0, 'b');
% Отображение дискретизированного сигнала
stem(t1(1:min(length(t1),length(s1))), s1,'r');
% Построение восстановленного сигнала
plot(t, s2, 'r');
plot(t, s3, 'k');
% Строим спектр дискретизированного сигнала
subplot(3,1,2);
stem(f, F1, 'diamondr');
% Накладываем на него спектр исходного сигнала
hold on
stem(f, F0(1:length(f)),'b');
grid on
stem(f, F2(1:length(f)),'squarek');
% График ошибки преобразованиия
subplot(3,1,3);
plot(t, ds);
grid on



